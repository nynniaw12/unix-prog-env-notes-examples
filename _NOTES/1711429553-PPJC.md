---
id: 1711429553-PPJC
aliases:
  - ch5
tags: []
area: ""
project: ""
---

# ch5

- example sed command to parse $PATH:

echo $PATH | sed 's/^:/.:/
                  s/::/:.:/g
                  s/:$/:./
                  s/:/ /g'

every command returns an exit status by default 0 meaning true
or non-zero meaning false, opposite of C

- test - stores the exit status of a program in $?

example:
    cmp /usr/you/.profile /usr/you/.profile
    echo $? # would produce 0 as command runs okay with both files being identical

shorthand usage:

test -f filename || echo file filename does not exist

is equivalent to:

if test ! -f filename
then
    echo file filename does not exist
fi

- if - block syntax

if cmd
then
else
fi

case statements are faster

- while and until loops

commands are executed until non-zero status in while

while command
do
    commands
done

commands are exececuted until zero status in until

until command
do
    commands
done

example to check if user mary is logged in:

while sleep 60
do
    who | grep mary
done

sleep 60 returns 0 every 60 seconds so will run every 60 seconds
hence if mary is logged you have to wait 60 seconds at worst to 
receive that she is logged in and you get mary is logged in messages
every 60 seconds when she is logged in

better implementation of the same:

until who | grep mary
do
    sleep 60
done

- variable conventions

$var is equivalent to ${var}

${var-thing} var if undefined thing

${var=thing} var if undefined thing but var is set to thing as well

${var?message} var if undefined print message and exit if message empty prints var: parameter not set

${var+thing} thing if var defined otherwise nothing

- signal processing with trap

- trap sequence-of-commands list-of-signal-numbers

- shell singal numbers

0 - shell exit
1 - hangup
2 - interrupt (DEL key)
3 - quit 
9 - kill (cannot be caught or ignored)
15 - terminate (default signal generated by kill)

example to prevent a program from being hangup (what nohup does):

(trap '' 1; long-running-command) &

- exec - replaces the process running he current shell with the named program

- kill -9 pid (-9 is unusual because it gives the process no time to put its affairs in order)

- overwrite

the sort command has an option -o to overwrite a file:

sort file1 -o fil2 is equivalent to sort file1 \>file2

many commands could be given this but it is impractical hence an intermediary overwrite program is better

shell internal field seperator (IFS variable) can be changed so that it is more useful in some cases such as zap

- read - read in var values from tty to a variable

none of the built in shell commands can be redirected with > or < except for control flow primitives like for

- get and put: tracking file changes

@@@ person date summary
editing commands

diff -e old new generates a list of ed commands to convert old to new

- the most important thing is not to have many programs or a programmable command language but
that all of the components work together
